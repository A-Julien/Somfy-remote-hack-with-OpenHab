import org.openhab.model.script.actions.*
import org.openhab.core.library.types.*
import org.openhab.core.types.*
import java.util.ArrayList
import java.lang.Math


var int Nbchoix = 5
var boolean lock = true
val ArrayList<String> Buffer = new ArrayList()

rule test
when 
	Item test received command
then
logDebug(" ule","fdp")
//callScript("timer")
	//timer = createTimer(now.plusMillis(5000),[|logDebug(" ule","fdp2")
	//timer = null])
callScript("Timer_timer")
logDebug(" ule","fin fdp")
end
  
rule Position
when 
	Item Positioning received command
then
	logDebug("Positioning rule","Startup Positioning rule")
	val com = receivedCommand.toString.splitByWholeSeparator(":")
	val choix = com.get(0)
	var int choixNUM = Integer::parseInt(com.get(1))
	var Number count = 0	
	
	//--- Init GPIO--//
	logDebug("Positioning rule","Init gpio")
	sendCommand(CommandChoice,OFF)
	sendCommand(UPCOM,OFF)
	sendCommand(DOWNCOM,OFF)
	sendCommand(MY,OFF)
	
	//--Wake UP--//
	logDebug("Positioning rule","Wake up remote")
	sendCommand(CommandChoice,ON)
	callScript("timer")
	sendCommand(CommandChoice,OFF)
	callScript("timer")	
	
	switch(choix){
		case "GO":{
			while(count < choixNUM){
				sendCommand(CommandChoice,ON)
				callScript("timer")
				sendCommand(CommandChoice,OFF)
				callScript("timer")
				count = count + 1
				logDebug("rolling shutter","->Cursor Position  : " + count)
			}
			sendCommand(Process,"OK")
		}
		case "RETURN":{
		//	Thread::sleep(100)
			logDebug("Positioning rule","Direction : Return")
			logDebug("Positioning rule","->Cursor Position  : " + choixNUM)
			choixNUM = Nbchoix - choixNUM
			while(count < choixNUM){
				sendCommand(CommandChoice,ON)
				callScript("timer")
				sendCommand(CommandChoice,OFF)
				callScript("timer")
				count = count + 1
				logDebug("rolling shutter","->Cursor Position : " + (choixNUM - count))
			}
			logDebug("Positioning","Waiting")
			callScript("long_timer")
			logDebug("Positioning","end")
			Buffer.remove(Buffer.last)
			lock = true
		}
	}

end

rule Rolling_Shutter
when 
	Item Process received command
then
	val room = Buffer.last.toString.splitByWholeSeparator(":").get(0)
	val position = Buffer.last.toString.splitByWholeSeparator(":").get(1)
	
	switch(room){
		case "UP":{
			logDebug("Room","UP")
			sendCommand(UPCOM,ON)
			callScript("timer")
			sendCommand(UPCOM,OFF)
			
		}
		case "DOWN":{
			logDebug("Room","DOWN")
			sendCommand(DOWNCOM,ON)
			callScript("timer")
			sendCommand(DOWNCOM,OFF)
		}
		case "MY":{
			logDebug("Room","MY")
			sendCommand(MY,ON)
			callScript("timer")
			sendCommand(MY,OFF)
		}
	}
	sendCommand(Positioning, "RETURN:" + position)
end

rule Bufferisation
when 
	Item shutter received command
then
	Buffer.add(receivedCommand.toString)
end


rule CronSec
when
	Time cron  "0/5 * * * * ?"
then
	logDebug("cron", "lock = " + lock + ", Buffersize = " + Buffer.size)
	
 	if( lock && Buffer.size != 0){
		lock = false
		sendCommand(order, Buffer.last)
		logDebug("COM","CMD SENT " + Buffer.last )
		var position = Buffer.last.toString.splitByWholeSeparator(":").get(1)
		sendCommand(Positioning, "GO:" + position)
	}else{
		switch(Buffer.size){
			case 0 :{
				logDebug("CronSec","void buffer" )
			}
			default :{
				logDebug("CronSec","Already lock" )
				logDebug("cron","Buffer = " + Buffer.toString)
			}
		}
	}
end


rule Detect_Metal
when
	Item metal received command
then
	logDebug("metal","SHUTTER DETECTED" )
end

rule meteo
when
	Item weather received command
then
	
	val Temperature = receivedCommand.toString.splitByWholeSeparator("=").get(0)
	val Hum = receivedCommand.toString.splitByWholeSeparator("=").get(1)
	
	if(Temperature.length <= 4){sendCommand(Temp, Temperature)}else{sendCommand(Temp, Temperature.substring(0,4))}
	
	if(Hum.length <= 4){sendCommand(Humidity, Hum)}else{sendCommand(Humidity, Hum.substring(0,4))}
	
	logDebug("weather", "Temperature" + Temperature +" Humidity = " + Hum)
end

rule PushBtn
when
	Item pushbtn received command
then
	sendCommand(CommandChoice,ON)
	callScript("timer")
	sendCommand(CommandChoice,OFF)
	callScript("timer")
end

// A faire
//Verifier la stabilitÃ© du timer



rule Temp_Out
when
	Item Temperature_Out changed
then
	logDebug("Temperature_Out", "Temperature_Out :" + Temperature_Out.state.toString)
end
/*
rule debug
when
	Item Humidity_Out2 changed
then
	var hum = Float::parseFloat(Humidity_Out2.state.toString)
	hum = (hum * 30)/50
	sendCommand(Hum2, hum)
	logDebug("weather", "Temperature : " + Temperature_Out.state.toString)
end

	
rule buffer

when 
	Item buff received command
then
	lock = false
	sendCommand(order, Buffer.last)
	logDebug("COM","CMD SENT " + Buffer.last )
	Buffer.remove(Buffer.last)
	lock2 = true
end
*/	

/* 
	logDebug("Safty","lock =" + lock.booleanValue.toString)
	if(lock){
			lock = false
			logDebug("Safty","lock  = " + lock.booleanValue.toString)
			sendCommand(order, receivedCommand.toString)
		}else{
			logDebug("Safty","lock NOT OK")
			switch(lock2){
				case true :{
					logDebug("Safty","lock2: OK")
					Buffer.add(receivedCommand.toString)
				}
				case false :{
					logInfo("Safty","can't add to buffer")
				}
			}
		}
		
*/

