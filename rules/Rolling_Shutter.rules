import org.openhab.model.script.actions.*
import org.openhab.core.library.types.*
import org.openhab.core.types.*
import java.util.ArrayList


var int Nbchoix = 5
var boolean lock = true
var boolean lock2 = true
val ArrayList<String> Buffer = new ArrayList()


rule test
when 
	Item test received command
then
logDebug(" ule","fdp")
//callScript("timer")
	//timer = createTimer(now.plusMillis(5000),[|logDebug(" ule","fdp2")
	//timer = null])
	Buffer.add("test1")
	Buffer.add("test2")
logDebug(" ule","buff" + Buffer.last)
 Buffer.remove(Buffer.last)
logDebug(" ule","buff" + Buffer.last)
logDebug(" ule","fin fdp")
end
  
rule Position
when 
	Item Positioning received command
then
	logDebug("Positioning rule","Startup Positioning rule")
	val com = receivedCommand.toString.splitByWholeSeparator(":")
	val choix = com.get(0)
	var int choixNUM = Integer::parseInt(com.get(1))
	var Number count = 0	
	logDebug("Positioning rule","5s avant")
	
	logDebug("Positioning rule","5s apres")
	//--- Init GPIO--//
	logDebug("Positioning rule","Init gpio")
	sendCommand(CommandChoice,OFF)
	sendCommand(UPCOM,OFF)
	sendCommand(DOWNCOM,OFF)
	sendCommand(MY,OFF)
	
	//--Wake UP--//
	logDebug("Positioning rule","Wake up remote")
	sendCommand(CommandChoice,ON)
	callScript("timer")
	sendCommand(CommandChoice,OFF)
	callScript("timer")	
	switch(choix){
		case "GO":{
			logDebug("Positioning rule","Direction : Go")
			callScript("timer")
			sendCommand(CommandChoice,OFF)
			logDebug("rule","TUATTENDBORDEL")
			callScript("timer")
			count = count + 1
			logDebug("rolling shutter","->Cursor Position  : " + count)
			sendCommand(Process, "OK")
			}
		case "RETURN":{
		//	Thread::sleep(100)
			logDebug("Positioning rule","Direction : Return")
			logDebug("Positioning rule","->Cursor Position  : " + choixNUM)
			choixNUM = Nbchoix - choixNUM
			while(count < choixNUM){
				sendCommand(CommandChoice,ON)
				callScript("timer")
				sendCommand(CommandChoice,OFF)
				callScript("timer")
				count = count + 1
				logDebug("rolling shutter","->Cursor Position : " + (choixNUM - count))
			}
			logDebug("Positioning","Waiting")
			callScript("long_timer")
			logDebug("Positioning","end")
			lock = true
		}
	}

end

rule Rolling_Shutter
when 
	Item order received command
then
	logDebug("Safty","lock =" + lock.booleanValue.toString)
	val room = receivedCommand.toString.splitByWholeSeparator(":").get(0)
	val position = receivedCommand.toString.splitByWholeSeparator(":").get(1)
	logDebug("Room"," room : " + room + "/Position : " + position)

	sendCommand(Process, "NOP") //Wait positioning cursor
	sendCommand(Positioning, "GO:" + position)
	logDebug("Room","Proces Positioningi")

	while(Process.state.toString != "OK"){}
	logDebug("Room","Positionnement curseur ok")
	
	switch(room){
		case "UP":{
			logDebug("Room","UP")
			sendCommand(UPCOM,ON)
			callScript("timer")
			sendCommand(UPCOM,OFF)
			
		}
		case "DOWN":{
			logDebug("Room","DOWN")
			sendCommand(DOWNCOM,ON)
			callScript("timer")
			sendCommand(DOWNCOM,OFF)
			callScript("timer")
		}
		case "MY":{
			logDebug("Room","MY")
			sendCommand(MY,ON)
			callScript("timer")
			sendCommand(MY,OFF)
		}
	}
	sendCommand(Positioning, "RETURN:" + position)
end

rule Safty
when 
	Item shutter received command
then
	Buffer.add(receivedCommand.toString)
	logDebug("cron","Buffer = " + Buffer.toString)
end


rule CronSec
when
	Time cron  "0/5 * * * * ?"
then
	logDebug("cron", "lock = " + lock + ", lock 2 = " + lock2 + ", Buffersize = " + Buffer.size)
	
 	if(lock2 && lock && Buffer.size != 0){
		lock = false
		sendCommand(order, Buffer.last)
		logDebug("COM","CMD SENT " + Buffer.last )
		Buffer.remove(Buffer.last)
		lock2 = true
		lock2 = false
	}else{
		switch(Buffer.size){
			case 0 :{
				logDebug("CronSec","void buffer" )
			}
			default :{
				logDebug("CronSec","Already lock" )
				logDebug("cron","Buffer = " + Buffer.toString)
			}
		}
	}
end


rule Detect_Metal
when
	Item metal received command
then
	logDebug("metal","SHUTTER DETECTED" )
end

rule meteo
when
	Item weather received command
then
	
	val Temperature = receivedCommand.toString.splitByWholeSeparator("=").get(0)
	val Hum = receivedCommand.toString.splitByWholeSeparator("=").get(1)
	
	if(Temperature.length <= 4){sendCommand(Temp, Temperature)}else{sendCommand(Temp, Temperature.substring(0,4))}
	
	if(Hum.length <= 4){sendCommand(Humidity, Hum)}else{sendCommand(Humidity, Hum.substring(0,4))}
	
	logDebug("weather", "Temperature" + Temperature +" Humidity = " + Hum)
end

rule PushBtn
when
	Item pushbtn received command
then
	sendCommand(CommandChoice,ON)
	callScript("timer")
	sendCommand(CommandChoice,OFF)
	callScript("timer")
end

// A faire
// Remplacer while d'attente par un Lock
//Verifier la stabilitÃ© du timer


/*	
rule buffer

when 
	Item buff received command
then
	lock = false
	sendCommand(order, Buffer.last)
	logDebug("COM","CMD SENT " + Buffer.last )
	Buffer.remove(Buffer.last)
	lock2 = true
end
*/	

/* 
	logDebug("Safty","lock =" + lock.booleanValue.toString)
	if(lock){
			lock = false
			logDebug("Safty","lock  = " + lock.booleanValue.toString)
			sendCommand(order, receivedCommand.toString)
		}else{
			logDebug("Safty","lock NOT OK")
			switch(lock2){
				case true :{
					logDebug("Safty","lock2: OK")
					Buffer.add(receivedCommand.toString)
				}
				case false :{
					logInfo("Safty","can't add to buffer")
				}
			}
		}
		
*/

